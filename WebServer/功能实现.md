

[Linux 新增系统调用的启示](https://blog.csdn.net/Solstice/article/details/532788)

# 目录
[eventloop](#EventLoop)
[Channel](#Channel)
[Poller](#Poller)
[Acceptor](#Acceptor)





## EventLoop


### 特殊性质
* one loop per thread，每个线程只能有一个EventLoop对象
* 创建了EventLoop对象的线程是IO线程，其主要功能是运行事件循环EventLoop::loop()
* 成员分为两类，一类可以跨线程调用，一类只能在创建了EventLoop的线程中调用

#### EventLoop中未命名的命名空间使用
* 未命名的命名空间中定义的变量拥有静态生命周期，在第一次使用前创建，并且直到程序结束才销毁，类似static关键字
* 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件
* 如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同的实体
* 未命名的命名空间中定义的名字的作用域与该命名空间所在的所用域相同，名字可以直接使用

#### eventfd
* eventfd 是 Linux 的一个系统调用，创建一个文件描述符用于事件通知
本程序中eventfd的使用是为了唤醒阻塞在poll调用中的IO线程。传统的方法是用pipe，IO线程始终监视着此管道的readable事件，在需要唤醒的时候，其他线程往管道里写一个字节，这样IO线程就从IO复用的poll调用中返回。现在使用eventf可以更高效的唤醒
* 创建对象
```cpp
#include <sys/eventfd.h>
int eventfd(unsigned int initval, int flags);
```
对象包含了由内核维护的无符号64位整数计数器 count 。使用参数 initval 初始化此计数器。
flags的可能取值如下：
>EFD_CLOEXEC (since Linux 2.6.27)
>文件被设置成 O_CLOEXEC，创建子进程 (fork) 时不继承父进程的文件描述符。
>EFD_NONBLOCK (since Linux 2.6.27)
>文件被设置成 O_NONBLOCK，执行 read / write 操作时，不会阻塞。
>EFD_SEMAPHORE (since Linux 2.6.30)
>提供类似信号量语义的 read 操作，简单说就是计数值 count 递减 1。

* 读写操作
    * read(): 读取 count 值后置 0。如果设置 EFD_SEMAPHORE，读到的值为 1，同时 count 值递减 1。。如果counter的值为0，非阻塞模式，会直接返回失败，并把errno的值置为EINVAL。如果为阻塞模式，一直会阻塞到counter为非0位置。
    * write(): 其实是执行 add 操作，累加 count 值。如果counter的值达到0xfffffffffffffffe时，就会阻塞。直到counter的值被read。阻塞和非阻塞情况同上面read一样。

#### 对SIGPIPE信号的处理
对于一个对端关闭了的socket进行两次写操作，第二次会产生一个SIGPIPE信号，该信号默认退出进程。
TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端已经完全关闭.

假设server和client 已经建立了连接，client 调用了close, 发送FIN 段给server（其实不一定会发送FIN段，close不能保证，只有当某个sockfd的引用计数为0，close 才会发送FIN段，否则只是将引用计数减1而已。也就是说只有当所有进程（可能fork多个子进程都打开了这个套接字）都关闭了这个套接字，close 才会发送FIN 段），此时client不能再通过socket发送和接收数据，此时server调用read，如果接收到FIN 段会返回0。但server此时还是可以write 给client的，write调用只负责把数据交给TCP发送缓冲区就可以成功返回了，所以不会出错，

而client收到数据后应答一个RST段，表示已经不能接收数据，连接重置，server收到RST段后无法立刻通知应用层，只把这个状态保存在TCP协议层。如果server再次调用write发数据给client，由于TCP协议层已经处于RST状态了，因此不会将数据发出，而是发一个SIGPIPE信号给应用层，SIGPIPE信号的缺省处理动作是终止程序。

有时候代码中需要连续多次调用write，可能还来不及调用read得知对方已关闭了连接就被SIGPIPE信号终止掉了，这就需要在初始化时调用sigaction处理SIGPIPE信号，对于这个信号的处理我们通常忽略即可，signal(SIGPIPE, SIG_IGN); 如果SIGPIPE信号没有导致进程异常退出（捕捉信号/忽略信号），write返回-1并且errno为EPIPE（Broken pipe）。（非阻塞地write）
close 关闭了自身数据传输的两个方向。
close把描述符的引用计数减一，仅在该计数变为零时才关闭套接字，而使用shutdown可以不管引用计数就激发TCP的正常连接终止序列
shutdown 可以选择关闭某个方向或者同时关闭两个方向，shutdown how = 0 or how = 1 or how = 2 (SHUT_RD or SHUT_WR or SHUT_RDWR)，后两者可以保证对等方接收到一个EOF字符（即发送了一个FIN段），而不管其他进程是否已经打开了这个套接字。所以说，如果是调用shutdown how = 1 ，则意味着往一个已经发送出FIN的套接字中写是允许的，接收到FIN段仅代表对方不再发送数据，但对方还是可以读取数据的，可以让对方可以继续读取缓冲区剩余的数据。
[参考文献](https://blog.csdn.net/u010982765/article/details/79038062)



#### 编译器处理警告
pragma GCC diagnostic [error|warning|ignored] "-W<警告选项>"
诊断-忽略:(关闭警告)
　　#pragma  GCC diagnostic ignored  "-Wunused"
　　#pragma  GCC diagnostic ignored  "-Wunused-parameter"

诊断-警告:(开启警告)
　　#pragma GCC diagnostic warning "-Wunused" 

　　#pragma GCC diagnostic warning "-Wunused-parameter"

诊断-错误:(开启警告-升级为错误)
　　#pragma GCC diagnostic error "-Wunused" 
　　#pragma GCC diagnostic error "-Wunused-parameter"

[常用警告选项](https://www.cnblogs.com/Dennis-mi/articles/7150321.html)


## Channel
* 自始至终只属于一个EventLoop，也即只属于一个IO线程
* 负责一个文件描述符的IO时间分发，但不拥有这个文件描述符，不会在析构时关闭这个文件描述符
* 主要功能是把不同的IO事件分发为不同的回调
* Channel在remove自身时，一定要调用disableAll
### 注册事件的函数调用
以可读事件为例
1. Channel::setReadCallback(): 注册回调函数
2. Channel::enableReading(): 开始监测可读事件，调用3
3. Channel::update():把自身加入owner EventLoop中，调用4
4. EventLoop::updateChannel(Channel *)：把Channel加入到Poller的监测列表中，调用5
5. Poller::updateChannel(Channel *)



## Poller
* 实现IO复用的类
* 同时支持poll和epoll
* 是EventLoop的间接成员，只供其owner EventLoop在IO线程调用
* 管理Channel,但不拥有Channel,Channel在析构之前必须自己解除在Poller中的注册


## Acceptor
* 供TcpServer使用，生命期由TcpServer控制
* 功能是用于accept 新的Tcp连接，并通过回调通知使用者
### 监听套接字和已连接套接字
###获取新连接的方式
* 每次accept一个socket
* 每次循环accept，直到没有新连接到达
* 每次尝试accept N个新连接，N的值一般是10
* 后面两种方法适合短连接读物，这里采用的是第一种方法
### EMFILE,文件描述符耗尽处理方法
P238

## TcpServer
* 为连接创建对应的TcpConnection对象


## EventLoopThreadPool
### 负载均衡算法
